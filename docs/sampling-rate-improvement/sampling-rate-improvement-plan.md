# データロガー サンプリングレート向上検討書

最終更新: 2025-08-28
対象: XIAO nRF52840 Sense データロガー（BLE/CSVインターフェースは現状維持）

---

## 目的と制約

- 目的: 実運用で取り回しを変えず（CSV over BLE/NUSの仕様・形式はそのまま）、可能な範囲で「有効サンプリングレート」を引き上げる。
- 制約: BLEインターフェース（NUS/CSVの列・区切り）は変更しない。受信側（bleak/Dash/録画）の既存機構は互換維持。

ここでの「サンプリングレート」は、主に「1秒あたりに収集・送出・受信・記録できるCSV行数（有効データ行数）」を指します。

---

## 現状把握（コード精読ベース）

送信側（sender/src/main.cpp）

- ループ: 約100Hz（末尾の delay(10)）。
- IMU読み出し: `readFloatAccelX/Y/Z` と `readFloatGyroX/Y/Z` を個別呼び出し（I2Cが軸毎に複数回往復）。
- PDM: 16kHz/10msフレームでRMS算出。行は「IMUスナップショット + 直近10ms RMS」の粗同期。
- CSV出力: Serialは毎ループ（~100Hz）。BLEはスロットリングで100ms周期（10Hz）に送出。帯域詰まり時はペンディング再送。
- BLE設定: `BANDWIDTH_MAX`、ConnInterval(6-12)、TX Power=4、NUSでNotify。行は1通知あたり1行+LFを原則。

受信側（receiver/src/xiao_nrf52840_sense_receiver）

- `ble_receiver.py`: bleakでNotify受信→バッファ組み立て→CSVパース。25Hz前提でも余力あり。
- `data_recorder.py`: DataBuffer差分をワーカースレッドが~40〜60ms間隔でCSVへ書出し（非ブロッキング）。
- `oscilloscope`: 可視化はCPU最適化課題だが、記録・受信のレート上限には直結しない。

概算の行サイズ（目安）

- 1行あたり: 70〜120バイト程度（timestamp + 8個のfloat、桁数に依存）。
- BLE 10Hzなら ~1KB/s、25Hzでも ~2.5KB/s 程度で、NUSの理論帯域（数十KB/s以上）にはかなり余裕。

→ 現状の主な上限要因は「送信側で100msに制限している送出間隔」と「IMU読み出し/整形コスト」。

---

## ボトルネックと改善余地

### 1. BLE送出のスロットリング（100ms）

- 現状コメントも「25Hz相当」を想定する箇所がある一方、実コードは100ms（10Hz）。
- BLE帯域は`BANDWIDTH_MAX`と短いConnIntervalで確保済み。CSV1行のサイズなら25Hz〜50Hzも現実的。

### 2. IMU読み出しのI2C往復回数

- 軸ごとに複数の`readFloat*`呼び出し→I2Cトランザクションが多い。
- LSM6DS3はオートインクリメントで連続レジスタを一括読み出し可能（OUT_TEMP_L〜Accel/Gyroの連続域をバーストで読む）。

### 3. フォーマット（浮動小数点のprintf）コスト

- `snprintf`で9個の浮動小数点変換。C標準の浮動小数点printfはコスト高。
- フォーマット自体は維持する必要があるため、関数呼び出し回数の削減やバッファ再利用が効果的。

### 4. 送信バッチング

- 1通知=1行の厳密性は不要。BLE通知1回で「2行まとめて」送ると通知回数が半分になりスループットが向上（受信側は改行で復元可）。

---

## 提案（段階導入、インターフェース不変）

段階A（低リスク・即効、まずはここから）

- A1: BLE送出間隔を100ms→40msに見直し（目標25Hz）。
  - 実装: `lastBle`間隔を40msに変更。パケット詰まり検知（連続0write時のドロップ）ロジックは現状維持。
  - 期待: 10Hz→25Hz へ。CSV・受信側は変更不要。
- A2: 送信の「軽バッチ」対応（オプション）。
  - 実装: 前回行が未完了で次行が到着した場合、`\n`区切りで同一通知に続けて送出（NUSはバイトストリーム）。
  - 期待: 通知回数を削減し、実効レートの頭打ちを緩和。
- A3: IMU読み出しのレイテンシ削減（最小限）。
  - 実装: LSM6DS3の連続レジスタをオートインクリメントで一括Read（温度+Gyro+Accelを14バイト+αの連続域で取得）。
  - 期待: 1ループ内のI2C取引回数を削減し、ループ遅延のばらつきを低減。

段階B（中リスク・効果大）

- B1: 送出間隔を40ms→20ms（目標50Hz）に段階引き上げ。
  - BLEの接続パラメータと環境ノイズにより安定度が左右されるため、Aの計測結果を踏まえて段階導入。
- B2: CSVフォーマットの内部最適化（形式は現状維持）。
  - 実装例: 単一`snpprintf`のまま、出力バッファの再利用/事前ゼロクリア排除、`dtostrf`など軽量変換の評価（サイズ増加/精度差に注意）。
- B3: 2行/通知の積極化＋行長の上限監視。
  - `BANDWIDTH_MAX`環境でMTU/データ長が拡大される（環境依存）ため、1通知に格納できる行数の上限をログで可視化し最適化。

段階C（高度）

- C1: LSM6DS3 FIFO + 高ODRで読み出し（行は現行フォーマット）。
  - センサ内部のFIFOからまとめ読み→ホスト側のI2C負荷をさらに低減。統合行は最新サンプルで作成。
- C2: 「Serial高レート、BLE中レート」の二系統最適化。
  - BLEは25〜50Hzに抑え、USB Serial側は100Hz〜に拡大（既に近い）。用途に応じて選択。

---

## 期待効果（目安）

- 段階Aのみ: 10Hz → 25Hz の実効レート（BLE）を安定達成。
- 段階Bまで: 条件良好時に 40〜50Hz 程度まで到達可能性。
- 送信ループのジッタ低減により、受信・記録のタイムスタンプ偏差が小さくなる見込み。

※ BLE環境（PC/ドングル/周囲電波/OSスタック）に依存して上限は変動します。

---

## 実装ポイント（ファイル別の具体化）

- sender/src/main.cpp
  - A1: `if (conn && (now - lastBle >= 100))` → `>= 40` へ変更。必要に応じて定数化。
  - A2: ペンディング送信バッファに「前行+改行+次行」を許容し、`bleWriteSome`でまとめ書き。
  - A3: LSM6DS3の連続レジスタ一括読み（OUT_TEMP_L(0x20)起点のオートインクリメント）に置換して、軸別の個別`readFloat*`呼び出し回数を削減。
  - B2: フォーマットバッファの再利用と`snprintf`呼び出しの最小化（形式・桁は現状維持）。
- 受信側（Python）は変更不要（行区切り復元の仕組みは既に複数デリミタ対応）。

---

## 検証・計測プラン

### 1. 送信側（ファーム）

- ループ内で`millis()`を埋め込み、BLE送出時刻の間隔ヒストグラムをUSB Serialへ出力（デバッグ時のみ）。
- 10分連続運用で平均周期・標準偏差・0write連発の頻度を集計。

### 2. 受信側（PC）

- `ble_receiver.py`の`BufferStats.sample_rate`をログ出力（10秒毎）。
- 記録ファイルのサンプル数/秒をメタに保存（既存機能）。

### 3. BLEパラメータ確認

- 接続インターバル・ATT MTU/データ長（可能ならログ/ツールで記録）。
- バッチ送出時の1通知あたりバイト数の傾向を収集。

判定基準

- 25Hz（±10%）を安定維持できること（10分以上の連続運用、ドロップなし）。
- 可能なら環境良好時に40〜50Hzでの連続運用が成立（限定条件で可）。

---

## リスク・留意点

- BLEスタックやOS/ドライバの差異でレート上限が変動。過度なスロットリング解除は接続不安定化の恐れ。
- LSM6DS3の一括読みはドライバ層の変更を伴う可能性（SeeedライブラリAPIの互換性に注意）。
- 浮動小数点printf最適化はコードサイズ/精度へ副作用の可能性。ビルドサイズ・数値差分の確認が必要。

---

## 次アクション（提案）

- [ ] A1 実装: BLE送出間隔を100ms→40msへ（定数化）
- [ ] A2 実装: 2行/通知の軽バッチ（任意）
- [ ] 計測: 連続10分で25Hz達成をログ確認（受信側`sample_rate`/メタ）
- [ ] A3 実装: IMU一括読み（I2Cバースト）→ ループ時間短縮を計測
- [ ] B1 検証: 条件良好時に20ms（50Hz）での安定性評価

以上。インターフェース（CSV/NUS）は不変のまま、まずは25Hzの安定達成、その後環境が許す範囲で段階的に引き上げる方針を推奨します。
