# receiver CPU負荷の現状分析と改善提案

最終更新: 2025-08-28
対象: `receiver/`（Dash/Plotly可視化 + BLE受信 + 録画）

---

## 目的と要求

- 可視化側の負荷を優先的に下げる（レンダリングを軽くする仕組み）。
- データ取得（BLE）と録画（CSV）では取りこぼしを発生させない。
- 既存アーキテクチャ（非同期/スレッド分離）を活かしつつ、体感のCPU使用率を有意に低減。

---

## 現状（コードリーディングによる把握）

対象主要ファイル:

- `receiver/src/xiao_nrf52840_sense_receiver/ble_receiver.py`
  - BLE受信、行再構成、`ImuRow`、`DataBuffer`（リングバッファ＋統計）
- `receiver/src/xiao_nrf52840_sense_receiver/data_recorder.py`
  - 非ブロッキング録画（ワーカースレッドが20ms間隔でポーリングしCSVへ）
- `receiver/src/xiao_nrf52840_sense_receiver/oscilloscope/app.py`
  - Dashアプリ本体。`dcc.Interval`（既定15fps）でコールバックし、
    毎フレーム `create_multi_plot_layout()` で図を作り直し
- `receiver/src/xiao_nrf52840_sense_receiver/oscilloscope/plots.py`
  - 4分割図（加速度、ジャイロ、温度、音）を毎回フル生成

観測ポイント:

- DataBuffer
  - `get_recent(N)` が `list(self._buffer)` でコピー作成 → その後複数リストに再分配
  - `stats.sample_rate` は1/Δtの瞬時値更新（軽量）
- Dash UI 更新
  - 15fpsで「毎回フル図生成 + 全データをJSON化してブラウザへ送信」
  - 1フレームで4サブプロット×複数トレース（加速度/ジャイロは3本ずつ）を新規構築
- 録画
  - バッファから差分取得→100行単位で書き出し（flush）。ワーカースレッドは20ms周期ポーリング

総論:

- CPU負荷の主因は「可視化側のフレームごとのフル再描画とデータシリアライズ量」。
- 取得/録画は既に非同期分離・リングバッファ化されており、可視化を軽くしても取りこぼしは発生しにくい設計。

---

## ボトルネック整理（推定）

 
### 1. フル再生成・全量再送

 ・毎フレーム `go.Figure` とサブプロット・トレースを新規作成（オブジェクト生成コスト）
・時間窓Nサンプルを毎回全量JSON化→ネットワーク/ブラウザでパース＆再レイアウト

 
### 2. Python側でのデータ加工の重複

 ・`get_recent()`→複数チャネル配列化（timestamps, ax/ay/az, gx/gy/gz, …）を毎フレーム作る

 
### 3. 更新レート（15fps）の過剰

 ・データ到来は約25Hz。UIは10fps程度でも視覚的連続性は維持可能。

 
### 4. 録画スレッドのポーリング

 ・20ms固定ウェイト（50Hz）でポーリング。書き込みがない時も起床→微小だが無駄起動。

---

## すぐ効く改善（小改修・低リスク）

優先度A（体感CPUを大きく下げやすい）

- UI更新fpsの引き下げ/可変化（既定: 15 → 8〜10fps）
  ・`OscilloscopeApp.__init__` の `update_rate` 既定値を10へ。
  ・レイテンシが許す際はさらに8fpsへ。視覚的にはほぼ遜色なく、CPU/帯域は顕著に低減。

- 時間窓の上限サンプル数を強制（例: 25Hz×20s=500 → 300〜400）
  ・`create_multi_plot_layout()` 内の `max_samples` を保守的に下げるオプション追加。
  ・ブラウザへのJSONサイズ縮小。線描画も軽くなる。

- WebGLレンダリングへ切替（Scatter → Scattergl）
  ・加速度/ジャイロの折れ線を `go.Scattergl` に変更（温度/音は通常でもOK）。
  ・大量点描画でCPU→GPUへオフロード。ブラウザ側レンダリング負荷を軽減。

- `uirevision` の固定でレイアウト再計算を抑制
  ・`figure.layout.uirevision` を固定値に設定して、毎フレームの不要な自動再レイアウトを回避。

- 録画ワーカの起床頻度を実測に合わせる（20ms → 40ms）
  ・センサ25Hzのため、40ms（25Hz）程度まで延長しても取りこぼしは発生しない。
  ・書き込みがあるフレームのみ短いスリープにする「二段スリープ」も有効。

優先度B（やや実装）

- 低コスト間引き（ストライド/簡易LTTB）
  ・可視化専用に N点超過時は等間引き or 近似LTTBでダウンサンプル。
  ・録画用データは無加工で保持されるため、取りこぼしなし。

- `DataBuffer.get_recent()` のコピー削減
  ・`list(deque)[-N:]` は毎回全コピー。必要分だけを取り出すスライス/キャッシュ層を設ける。
  ・例：直近の「前回可視化以降の追加分」だけ保持し、結合してウィンドウを更新。

---

## 中規模の改善（効果大、変更は増える）

- 増分更新（extendData/部分更新）による“全量再送の撤廃”

  ・Dashの`dcc.Graph`は`extendData`でトレースに点を追加可能。
  ・仕組み:
    ・初回のみ空（または最小限）のFigureを構築。
    ・以降は「新規サンプル分のみ」を`extendData`で追記。`maxPoints`で時間窓を維持。
  ・メリット:
    ・毎フレームのFigure再構築/全量JSON送信が不要→CPU/帯域が大幅減。
    ・取りこぼし対策: 追加点はバッファ差分で算出（録画とは独立）。

- Dashの部分更新（dash.Patch）活用

  ・Dash 3系は`dash.Patch`でFigureの該当配列だけ差し替え可能。
  ・既存のFigure/レイアウトを保持し、`data[i].x/y`のみ更新する形に変更。
  ・`extendData`が適さないケース（ウィンドウ切替・可視/不可視切替）と併用。

- クライアントサイドコールバック（JS）で描画更新

  ・Python→JSON→ブラウザの往復を最小化し、ブラウザ側で`extendData`適用。
  ・サーバCPU負荷をさらに下げ、フレーム詰まり時の回復も高速化。

---

## 実装ガイド（段階導入）

段階1（小改修、速効）
 
- [ ] 既定FPSを10へ（ユーザ設定化）
- [ ] WebGLへ切替（加速度/ジャイロ）
- [ ] uirevision固定
- [ ] 時間窓サンプル上限300〜400のオプション追加（既定有効）
- [ ] 録画ポーリングを40msへ、書き込み有/無で二段スリープ

段階2（中規模）
 
- [ ] `create_multi_plot_layout()` を「初期構築」と「差分更新」に分離
- [ ] `dash.Patch`ベースの部分更新or `extendData`実装
  - 可能なら `extendData`（`maxPoints`でウィンドウ維持）が最軽量
  - 切替時（可視/不可視、時間窓変更）は`Patch`で一括反映
- [ ] DataBuffer差分API（可視化用）
  - 「前回時刻以降の新規データ」を返すヘルパを追加

段階3（高度）
 
- [ ] クライアントサイド（JS）への`extendData`移行
  - Python側は新規点の配列のみ返す軽量コールバック
- [ ] 可視化専用ダウンサンプル（LTTB等）の導入

---

## 変更影響とリスク評価

- 取得/録画への影響: なし（既に生産者-消費者分離、録画はリングバッファ差分で追従）
- 可視化品質: 10fpsでも実運用視認性◎。ダウンサンプルは視覚専用で元データ保持。
- 後方互換: UIオプションに集約（元の挙動にも戻せる）

---

## 計測・検証プラン

- サーバCPU/メモリ: `psutil`でサンプリング記録（before/after）
- ブラウザ側: DevTools Performanceでフレーム時間、レイアウト/ペイント時間を比較
- 帯域: DevTools Networkで`figure`/`extendData`のペイロード比較
- 正常性: 連続30分以上の取得/録画/可視化でドロップ/エラーが無いこと

---

## 具体的なコード改修ポイント（ファイル別）

- `oscilloscope/app.py`
  - `update_rate` 既定値を10へ
  - `dcc.Interval`の`interval`見直しと「処理遅延時はスキップ」ロジック（タイムスタンプで重複実行抑止）
  - コールバックを「初期レイアウト構築」と「差分更新」に分割
  - `dash.Patch` or `extendData`を使った部分更新に置換
  - `uirevision`設定
- `oscilloscope/plots.py`
  - `go.Scattergl`へ切替（加速度/ジャイロ）
  - 時間窓サンプル数上限の適用
  - 必要なら簡易ダウンサンプル
- `data_recorder.py`
  - ワーカースレッドのウェイトを40msに（新規データが無いときは更に長め）
- `ble_receiver.py`
  - 可視化用差分取得の補助（任意）。録画APIは現状維持。

---

## 導入順と期待効果（目安）

- 段階1のみ: サーバ/ブラウザ合計CPU 20〜40%減（環境依存）
- 段階2まで: さらに20〜40%減（全量再送→差分更新で劇的に軽量化）
- 段階3まで: サーバCPUは低位安定、長時間運用での安定性向上

※ 上記は一般的なDash/Plotly構成での経験則。実測で最適化。

---

## 参考メモ（機能仕様）

- Dash 3系: `dash.Patch` による部分更新（Figureの`data[i].x/y`だけ差し替え）
- dcc.Graph: `extendData` でトレースへの増分追記 + `maxPoints`保持
- Plotly: `go.Scattergl` は大量点の描画をGPUにオフロード
- `layout.uirevision` 固定でユーザ操作（ズーム/パン）を保持しつつ再レイアウト抑制

---

## 結論

- 現状の設計は「取りこぼし防止（非同期分離・リングバッファ）」が良くできているため、
  可視化側の「全量再生成・全量再送」を“増分更新”へ置き換えるのが最も効果的。
- まずはFPS引き下げ、Scattergl、uirevision固定、サンプル上限で即効性のある改善を入れ、
  次に`extendData`/`dash.Patch`で差分更新化を進めるのが安全かつ費用対効果が高い。
